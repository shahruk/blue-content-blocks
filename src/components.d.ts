/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ContentLineTextAlignOptions as ContentLineTextAlignOptions1, ContentVerticalAlignments, FLEX_JUSTIFY_OPTIONS, GRID_TYPES, ResponsiveBoolean, ResponsiveNumber, ResponsiveString } from "./typings";
import { InitMethodType } from "./components/content-carousel/content-carousel";
import { HeroContentPlacementOptions } from "./blocks/content-hero-block/content-hero-block";
import { ContentLineTagOptions, ContentLineTextAlignOptions } from "./elements/content-line/content-line";
import { SupportedVideoMethods } from "./elements/content-video/content-video";
export namespace Components {
    interface ContentAccordion {
    }
    interface ContentBlockFormatter {
    }
    interface ContentBlockWrapper {
        "background": ResponsiveString;
        "backgroundClasses": string;
        "maxWidth": ResponsiveNumber;
        "name": string;
        "styleClasses": string;
    }
    interface ContentButton {
        "clickableBlock": boolean;
        "controls": string;
        "expanded": string;
        "href": string;
        "href2": string;
        "styleClass"?: string;
        "target": string;
    }
    interface ContentCarousel {
        "background": string;
        "initMethod": InitMethodType;
        "mobileBackground": string;
        "swiperOptions": string;
    }
    interface ContentElementWrapper {
        "name": string;
        "styleClasses": string;
    }
    interface ContentFormatterWrapper {
        "background": string;
        "extraClasses": string;
        "name": string;
    }
    interface ContentGridFormatter {
        "columns": ResponsiveNumber;
        "flexAlign": FLEX_JUSTIFY_OPTIONS | ResponsiveString;
        "flexGrow": ResponsiveBoolean;
        "flexShrink": ResponsiveBoolean;
        "type": GRID_TYPES | ResponsiveString;
    }
    interface ContentGroup {
        "background": string;
        /**
          * A ResponsiveString of ContentLineTextAlignOptions
         */
        "horizontalAlignment": ResponsiveString;
        "mobileBackground": string;
    }
    interface ContentHeroBlock {
        "background": ResponsiveString;
        /**
          * Pipe separated HeroContentPlacementOptions that will determine where the content is positioned with the media.
         */
        "contentPosition": ResponsiveString | HeroContentPlacementOptions;
    }
    interface ContentImage {
        "alt": ResponsiveString;
        "height": ResponsiveNumber;
        "lazyLoad": boolean;
        "src": ResponsiveString;
        "videoType"?: string;
        "width": ResponsiveNumber;
    }
    interface ContentLine {
        /**
          * Pipe separated list of max width numbers. You can also use units such as "px" and "vw".
         */
        "maxWidth": ResponsiveNumber;
        /**
          * The font class for the line.
         */
        "styleClass": ResponsiveString;
        /**
          * The element tag to use.
         */
        "tag": ContentLineTagOptions;
        /**
          * Pipe separated list of ContentLineTextAlignOptions for text alignment.
         */
        "textAlign": ContentLineTextAlignOptions | ResponsiveString;
    }
    interface ContentOverlay {
        /**
          * Title attribute value for the close button.
         */
        "closeTitle": string;
        "fullScreen": ResponsiveBoolean;
        /**
          * A pipe delimited setting for horizontal alignment. This only applies when fullscreen mode is activated.
         */
        "horizontalAlignment": ContentLineTextAlignOptions | ResponsiveString;
        "styleClass": ResponsiveString;
        "target": string;
        /**
          * A pipe delimited setting for vertical alignment. This only applies when fullscreen mode is activated.
         */
        "verticalAlignment": ContentVerticalAlignments | ResponsiveString;
    }
    interface ContentSpacingWrapper {
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "bottomOffset": ResponsiveNumber;
        /**
          * Pipe separated boolean values for full height. Typically, this is used if you have a hero block and you want a footer that aligns with the text layer. This is a niche case, but a valid one.
         */
        "fullHeight": ResponsiveBoolean;
        /**
          * Pipe separated list of ContentLineTextAlignOptions for where to place text box when a max width is specified.
         */
        "horizontalAlignment": ContentLineTextAlignOptions | ResponsiveString;
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "leftOffset": ResponsiveNumber;
        /**
          * Pipe separated list of max width numbers. You can also use units such as "px" and "vw".
         */
        "maxWidth": ResponsiveNumber;
        /**
          * A custom class to use as the offset. This cannot be pipe separated, because this causes repaint of content.
         */
        "offsetClass": string;
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "rightOffset": ResponsiveNumber;
        /**
          * Pipe separated list of ContentLineTextAlignOptions for text alignment.
         */
        "textAlign": ContentLineTextAlignOptions | ResponsiveString;
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "topOffset": ResponsiveNumber;
    }
    interface ContentSplitBlock {
        "background": string;
        "reverse": boolean;
    }
    interface ContentTabs {
    }
    interface ContentTextBlock {
        "background": ResponsiveString;
        /**
          * This is a string representing the theme class. This value must be  created in a custom theme stylesheet using `@include responsiveProperty`. This will output in the following format: `theme-${breakpoint}-${value}`
         */
        "colorClass": ResponsiveString;
        /**
          * Pipe separated list of ContentVerticalAlignments for text box placement.
         */
        "verticalAlignment": ContentVerticalAlignments | ResponsiveString;
    }
    interface ContentToutBlock {
        "hover": ResponsiveBoolean;
    }
    interface ContentVideo {
        /**
          * If you're using this inside a content-overlay for example, you may want the video to play immediately on launch.
         */
        "autoplay": boolean;
        "controls": boolean;
        /**
          * If this video is opened within a container, e.g. a <content-overlay> with a target. The height of the video will fit the container instead of resizing to the video aspect ratio.
         */
        "fitContainer": boolean;
        "height": number;
        "method": SupportedVideoMethods;
        "preload": string;
        "src": string;
        "styleClasses": string;
        "type": string;
        "width": number;
    }
}
declare global {
    interface HTMLContentAccordionElement extends Components.ContentAccordion, HTMLStencilElement {
    }
    var HTMLContentAccordionElement: {
        prototype: HTMLContentAccordionElement;
        new (): HTMLContentAccordionElement;
    };
    interface HTMLContentBlockFormatterElement extends Components.ContentBlockFormatter, HTMLStencilElement {
    }
    var HTMLContentBlockFormatterElement: {
        prototype: HTMLContentBlockFormatterElement;
        new (): HTMLContentBlockFormatterElement;
    };
    interface HTMLContentBlockWrapperElement extends Components.ContentBlockWrapper, HTMLStencilElement {
    }
    var HTMLContentBlockWrapperElement: {
        prototype: HTMLContentBlockWrapperElement;
        new (): HTMLContentBlockWrapperElement;
    };
    interface HTMLContentButtonElement extends Components.ContentButton, HTMLStencilElement {
    }
    var HTMLContentButtonElement: {
        prototype: HTMLContentButtonElement;
        new (): HTMLContentButtonElement;
    };
    interface HTMLContentCarouselElement extends Components.ContentCarousel, HTMLStencilElement {
    }
    var HTMLContentCarouselElement: {
        prototype: HTMLContentCarouselElement;
        new (): HTMLContentCarouselElement;
    };
    interface HTMLContentElementWrapperElement extends Components.ContentElementWrapper, HTMLStencilElement {
    }
    var HTMLContentElementWrapperElement: {
        prototype: HTMLContentElementWrapperElement;
        new (): HTMLContentElementWrapperElement;
    };
    interface HTMLContentFormatterWrapperElement extends Components.ContentFormatterWrapper, HTMLStencilElement {
    }
    var HTMLContentFormatterWrapperElement: {
        prototype: HTMLContentFormatterWrapperElement;
        new (): HTMLContentFormatterWrapperElement;
    };
    interface HTMLContentGridFormatterElement extends Components.ContentGridFormatter, HTMLStencilElement {
    }
    var HTMLContentGridFormatterElement: {
        prototype: HTMLContentGridFormatterElement;
        new (): HTMLContentGridFormatterElement;
    };
    interface HTMLContentGroupElement extends Components.ContentGroup, HTMLStencilElement {
    }
    var HTMLContentGroupElement: {
        prototype: HTMLContentGroupElement;
        new (): HTMLContentGroupElement;
    };
    interface HTMLContentHeroBlockElement extends Components.ContentHeroBlock, HTMLStencilElement {
    }
    var HTMLContentHeroBlockElement: {
        prototype: HTMLContentHeroBlockElement;
        new (): HTMLContentHeroBlockElement;
    };
    interface HTMLContentImageElement extends Components.ContentImage, HTMLStencilElement {
    }
    var HTMLContentImageElement: {
        prototype: HTMLContentImageElement;
        new (): HTMLContentImageElement;
    };
    interface HTMLContentLineElement extends Components.ContentLine, HTMLStencilElement {
    }
    var HTMLContentLineElement: {
        prototype: HTMLContentLineElement;
        new (): HTMLContentLineElement;
    };
    interface HTMLContentOverlayElement extends Components.ContentOverlay, HTMLStencilElement {
    }
    var HTMLContentOverlayElement: {
        prototype: HTMLContentOverlayElement;
        new (): HTMLContentOverlayElement;
    };
    interface HTMLContentSpacingWrapperElement extends Components.ContentSpacingWrapper, HTMLStencilElement {
    }
    var HTMLContentSpacingWrapperElement: {
        prototype: HTMLContentSpacingWrapperElement;
        new (): HTMLContentSpacingWrapperElement;
    };
    interface HTMLContentSplitBlockElement extends Components.ContentSplitBlock, HTMLStencilElement {
    }
    var HTMLContentSplitBlockElement: {
        prototype: HTMLContentSplitBlockElement;
        new (): HTMLContentSplitBlockElement;
    };
    interface HTMLContentTabsElement extends Components.ContentTabs, HTMLStencilElement {
    }
    var HTMLContentTabsElement: {
        prototype: HTMLContentTabsElement;
        new (): HTMLContentTabsElement;
    };
    interface HTMLContentTextBlockElement extends Components.ContentTextBlock, HTMLStencilElement {
    }
    var HTMLContentTextBlockElement: {
        prototype: HTMLContentTextBlockElement;
        new (): HTMLContentTextBlockElement;
    };
    interface HTMLContentToutBlockElement extends Components.ContentToutBlock, HTMLStencilElement {
    }
    var HTMLContentToutBlockElement: {
        prototype: HTMLContentToutBlockElement;
        new (): HTMLContentToutBlockElement;
    };
    interface HTMLContentVideoElement extends Components.ContentVideo, HTMLStencilElement {
    }
    var HTMLContentVideoElement: {
        prototype: HTMLContentVideoElement;
        new (): HTMLContentVideoElement;
    };
    interface HTMLElementTagNameMap {
        "content-accordion": HTMLContentAccordionElement;
        "content-block-formatter": HTMLContentBlockFormatterElement;
        "content-block-wrapper": HTMLContentBlockWrapperElement;
        "content-button": HTMLContentButtonElement;
        "content-carousel": HTMLContentCarouselElement;
        "content-element-wrapper": HTMLContentElementWrapperElement;
        "content-formatter-wrapper": HTMLContentFormatterWrapperElement;
        "content-grid-formatter": HTMLContentGridFormatterElement;
        "content-group": HTMLContentGroupElement;
        "content-hero-block": HTMLContentHeroBlockElement;
        "content-image": HTMLContentImageElement;
        "content-line": HTMLContentLineElement;
        "content-overlay": HTMLContentOverlayElement;
        "content-spacing-wrapper": HTMLContentSpacingWrapperElement;
        "content-split-block": HTMLContentSplitBlockElement;
        "content-tabs": HTMLContentTabsElement;
        "content-text-block": HTMLContentTextBlockElement;
        "content-tout-block": HTMLContentToutBlockElement;
        "content-video": HTMLContentVideoElement;
    }
}
declare namespace LocalJSX {
    interface ContentAccordion {
    }
    interface ContentBlockFormatter {
    }
    interface ContentBlockWrapper {
        "background"?: ResponsiveString;
        "backgroundClasses"?: string;
        "maxWidth"?: ResponsiveNumber;
        "name"?: string;
        "onContentBlockReady"?: (event: CustomEvent<HTMLElement>) => void;
        "styleClasses"?: string;
    }
    interface ContentButton {
        "clickableBlock"?: boolean;
        "controls"?: string;
        "expanded"?: string;
        "href"?: string;
        "href2"?: string;
        "onContentBlockActivated"?: (event: CustomEvent<HTMLElement>) => void;
        "styleClass"?: string;
        "target"?: string;
    }
    interface ContentCarousel {
        "background"?: string;
        "initMethod"?: InitMethodType;
        "mobileBackground"?: string;
        "swiperOptions"?: string;
    }
    interface ContentElementWrapper {
        "name"?: string;
        "styleClasses"?: string;
    }
    interface ContentFormatterWrapper {
        "background"?: string;
        "extraClasses"?: string;
        "name"?: string;
    }
    interface ContentGridFormatter {
        "columns"?: ResponsiveNumber;
        "flexAlign"?: FLEX_JUSTIFY_OPTIONS | ResponsiveString;
        "flexGrow"?: ResponsiveBoolean;
        "flexShrink"?: ResponsiveBoolean;
        "type"?: GRID_TYPES | ResponsiveString;
    }
    interface ContentGroup {
        "background"?: string;
        /**
          * A ResponsiveString of ContentLineTextAlignOptions
         */
        "horizontalAlignment"?: ResponsiveString;
        "mobileBackground"?: string;
    }
    interface ContentHeroBlock {
        "background"?: ResponsiveString;
        /**
          * Pipe separated HeroContentPlacementOptions that will determine where the content is positioned with the media.
         */
        "contentPosition"?: ResponsiveString | HeroContentPlacementOptions;
    }
    interface ContentImage {
        "alt"?: ResponsiveString;
        "height"?: ResponsiveNumber;
        "lazyLoad"?: boolean;
        "src": ResponsiveString;
        "videoType"?: string;
        "width"?: ResponsiveNumber;
    }
    interface ContentLine {
        /**
          * Pipe separated list of max width numbers. You can also use units such as "px" and "vw".
         */
        "maxWidth"?: ResponsiveNumber;
        /**
          * The font class for the line.
         */
        "styleClass"?: ResponsiveString;
        /**
          * The element tag to use.
         */
        "tag"?: ContentLineTagOptions;
        /**
          * Pipe separated list of ContentLineTextAlignOptions for text alignment.
         */
        "textAlign"?: ContentLineTextAlignOptions | ResponsiveString;
    }
    interface ContentOverlay {
        /**
          * Title attribute value for the close button.
         */
        "closeTitle"?: string;
        "fullScreen"?: ResponsiveBoolean;
        /**
          * A pipe delimited setting for horizontal alignment. This only applies when fullscreen mode is activated.
         */
        "horizontalAlignment"?: ContentLineTextAlignOptions | ResponsiveString;
        "onContentOverlayActivated"?: (event: CustomEvent<HTMLElement>) => void;
        "styleClass"?: ResponsiveString;
        "target"?: string;
        /**
          * A pipe delimited setting for vertical alignment. This only applies when fullscreen mode is activated.
         */
        "verticalAlignment"?: ContentVerticalAlignments | ResponsiveString;
    }
    interface ContentSpacingWrapper {
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "bottomOffset"?: ResponsiveNumber;
        /**
          * Pipe separated boolean values for full height. Typically, this is used if you have a hero block and you want a footer that aligns with the text layer. This is a niche case, but a valid one.
         */
        "fullHeight"?: ResponsiveBoolean;
        /**
          * Pipe separated list of ContentLineTextAlignOptions for where to place text box when a max width is specified.
         */
        "horizontalAlignment"?: ContentLineTextAlignOptions | ResponsiveString;
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "leftOffset"?: ResponsiveNumber;
        /**
          * Pipe separated list of max width numbers. You can also use units such as "px" and "vw".
         */
        "maxWidth"?: ResponsiveNumber;
        /**
          * A custom class to use as the offset. This cannot be pipe separated, because this causes repaint of content.
         */
        "offsetClass"?: string;
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "rightOffset"?: ResponsiveNumber;
        /**
          * Pipe separated list of ContentLineTextAlignOptions for text alignment.
         */
        "textAlign"?: ContentLineTextAlignOptions | ResponsiveString;
        /**
          * Pipe separated numbers between 0 and 100.
         */
        "topOffset"?: ResponsiveNumber;
    }
    interface ContentSplitBlock {
        "background"?: string;
        "reverse"?: boolean;
    }
    interface ContentTabs {
    }
    interface ContentTextBlock {
        "background"?: ResponsiveString;
        /**
          * This is a string representing the theme class. This value must be  created in a custom theme stylesheet using `@include responsiveProperty`. This will output in the following format: `theme-${breakpoint}-${value}`
         */
        "colorClass"?: ResponsiveString;
        /**
          * Pipe separated list of ContentVerticalAlignments for text box placement.
         */
        "verticalAlignment"?: ContentVerticalAlignments | ResponsiveString;
    }
    interface ContentToutBlock {
        "hover"?: ResponsiveBoolean;
    }
    interface ContentVideo {
        /**
          * If you're using this inside a content-overlay for example, you may want the video to play immediately on launch.
         */
        "autoplay"?: boolean;
        "controls"?: boolean;
        /**
          * If this video is opened within a container, e.g. a <content-overlay> with a target. The height of the video will fit the container instead of resizing to the video aspect ratio.
         */
        "fitContainer"?: boolean;
        "height"?: number;
        "method"?: SupportedVideoMethods;
        "preload"?: string;
        "src"?: string;
        "styleClasses"?: string;
        "type"?: string;
        "width"?: number;
    }
    interface IntrinsicElements {
        "content-accordion": ContentAccordion;
        "content-block-formatter": ContentBlockFormatter;
        "content-block-wrapper": ContentBlockWrapper;
        "content-button": ContentButton;
        "content-carousel": ContentCarousel;
        "content-element-wrapper": ContentElementWrapper;
        "content-formatter-wrapper": ContentFormatterWrapper;
        "content-grid-formatter": ContentGridFormatter;
        "content-group": ContentGroup;
        "content-hero-block": ContentHeroBlock;
        "content-image": ContentImage;
        "content-line": ContentLine;
        "content-overlay": ContentOverlay;
        "content-spacing-wrapper": ContentSpacingWrapper;
        "content-split-block": ContentSplitBlock;
        "content-tabs": ContentTabs;
        "content-text-block": ContentTextBlock;
        "content-tout-block": ContentToutBlock;
        "content-video": ContentVideo;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "content-accordion": LocalJSX.ContentAccordion & JSXBase.HTMLAttributes<HTMLContentAccordionElement>;
            "content-block-formatter": LocalJSX.ContentBlockFormatter & JSXBase.HTMLAttributes<HTMLContentBlockFormatterElement>;
            "content-block-wrapper": LocalJSX.ContentBlockWrapper & JSXBase.HTMLAttributes<HTMLContentBlockWrapperElement>;
            "content-button": LocalJSX.ContentButton & JSXBase.HTMLAttributes<HTMLContentButtonElement>;
            "content-carousel": LocalJSX.ContentCarousel & JSXBase.HTMLAttributes<HTMLContentCarouselElement>;
            "content-element-wrapper": LocalJSX.ContentElementWrapper & JSXBase.HTMLAttributes<HTMLContentElementWrapperElement>;
            "content-formatter-wrapper": LocalJSX.ContentFormatterWrapper & JSXBase.HTMLAttributes<HTMLContentFormatterWrapperElement>;
            "content-grid-formatter": LocalJSX.ContentGridFormatter & JSXBase.HTMLAttributes<HTMLContentGridFormatterElement>;
            "content-group": LocalJSX.ContentGroup & JSXBase.HTMLAttributes<HTMLContentGroupElement>;
            "content-hero-block": LocalJSX.ContentHeroBlock & JSXBase.HTMLAttributes<HTMLContentHeroBlockElement>;
            "content-image": LocalJSX.ContentImage & JSXBase.HTMLAttributes<HTMLContentImageElement>;
            "content-line": LocalJSX.ContentLine & JSXBase.HTMLAttributes<HTMLContentLineElement>;
            "content-overlay": LocalJSX.ContentOverlay & JSXBase.HTMLAttributes<HTMLContentOverlayElement>;
            "content-spacing-wrapper": LocalJSX.ContentSpacingWrapper & JSXBase.HTMLAttributes<HTMLContentSpacingWrapperElement>;
            "content-split-block": LocalJSX.ContentSplitBlock & JSXBase.HTMLAttributes<HTMLContentSplitBlockElement>;
            "content-tabs": LocalJSX.ContentTabs & JSXBase.HTMLAttributes<HTMLContentTabsElement>;
            "content-text-block": LocalJSX.ContentTextBlock & JSXBase.HTMLAttributes<HTMLContentTextBlockElement>;
            "content-tout-block": LocalJSX.ContentToutBlock & JSXBase.HTMLAttributes<HTMLContentToutBlockElement>;
            "content-video": LocalJSX.ContentVideo & JSXBase.HTMLAttributes<HTMLContentVideoElement>;
        }
    }
}
